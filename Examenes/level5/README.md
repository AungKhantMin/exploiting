# Bypass check with strcpy and overflow + Anti-Debugging
<b>Overview</b>
- Our buffer has a 200 bytes of size <code>ebp+Dest</code> and use <code>strcpy()</code> function to copy 200 bytes from other buffer <code>ebp+Dst</code> to the previous one, so we can't overflow like before challenges but writing zero value in the last value of the buffer <code>ebp+Dst</code> we don't write <code>ebp</code> because of we write a zero, <code>strcpy()</code> function copy until zero value and not get overflow and we keep the constant value.
- Bypass anti-debugging and figure out how the value to sum 0x2 == 0x46.
<pre><code>
<b>Reverse Engineering</b>
.text:00F11051 loc_F11051:                             ; CODE XREF: check+2A
.text:00F11051                 mov     eax, [ebp+arg_0]
.text:00F11054                 movsx   ecx, byte ptr [eax]
.text:00F11057                 cmp     ecx, 0Dh                                              #Anti-Debugging == 0xd (Heap)
.text:00F1105A                 jz      short loc_F11065
.text:00F1105C                 mov     edx, [ebp+arg_0]
.text:00F1105F                 mov     dword ptr [edx], 2                                    #Not debugging so edx = 0x2
.text:00F11065
.text:00F11065 loc_F11065:                             ; CODE XREF: check+4A
.text:00F11065                 mov     eax, [ebp+arg_0]
.text:00F11068                 movsx   ecx, byte ptr [eax]
.text:00F1106B                 push    ecx
.text:00F1106C                 push    offset aValorX  ; "valor= %x\n"
.text:00F11071                 call    sub_F112C0
.text:00F11076                 add     esp, 8
.text:00F11079                 mov     edx, [ebp+arg_0]
.text:00F1107C                 movsx   eax, byte ptr [edx+0CCh]                              #edx+0xCC has to be 0x44
.text:00F11083                 push    eax
.text:00F11084                 push    offset aNumberX ; "number= %x\n"
.text:00F11089                 call    sub_F112C0
.text:00F1108E                 add     esp, 8
.text:00F11091                 mov     ecx, [ebp+arg_0]
.text:00F11094                 mov     edx, [ecx+0CCh]                                       
.text:00F1109A                 mov     eax, [ebp+arg_0]
.text:00F1109D                 add     edx, [eax]                                            #0x44+0x2 = 0x46                                          
.text:00F1109F                 cmp     edx, 46h                                              #Bypass because it is equal
.text:00F110A2                 jnz     short loc_F110B9
.text:00F110A4                 push    offset aAprobasteLevel ; "Aprobaste level 5"          #Win
.text:00F110A9                 call    sub_F112C0
</code></pre>
