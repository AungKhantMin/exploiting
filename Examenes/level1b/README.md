# Buffer Overflow overwriting random value with bypass jl condition
<b>Overview</b>
- Function <code>atoi()</code> returns the converted integral number as an int value. If no valid conversion could be performed, it returns zero, <code>eax=0</code>
- We need write more than 0xc8 in other to get buffer overflow and bypass <code>jl</code> condition, it performs a <b>signed</b> comparison jump after a cmp if the destination operand is less than the source operand. So if we use a negative number like <code>-1</code> or in hex <code>0xffffffff</code> we bypass size and check <i>kill two birds with one stone</i>.
-XOR operation to pass level.
<b>Static Stack overview</b>
<pre><code>
-000000DC Dst             dd 50 dup(?)
-00000014 var_14          dd ?
-00000010 numero_random   dd ?
-0000000C var_C           dd ?
-00000008 ElementSize     dd ?
-00000004 File            dd ?                    ; offset
+00000000  s              db 4 dup(?)
+00000004  r              db 4 dup(?)
+00000008
+00000008 ; end of stack variables
</code></pre>
<b>Debugging Stack overview after third fread()</b>
<pre><code>
+----------------------+
|...higher addresses...|
+----------------------+
|         0x41         | <-- #padding 204 bytes
+----------------------+
|      0x44434241      | <-- ebp+numero_random
+----------------------+
|          0x0         | <-- ebp+var_C
+----------------------+
|      0x44434241      | <-- ebp+var_14  #after XOR Operation
+----------------------+
|      0xffffffff      | <-- ebp+ElementSize 
+----------------------+
|         ebp          | 
+----------------------+
|    [return addr]     | <-- return address 
+----------------------+
|...lower addresses....| <-- other data from previous function
+----------------------+
</code></pre>
<code>XOR Operation: 0x44434241 ^ 0x0 = ebp+var_14</code>
