# Bypass two check and set one value to print
<b>Reverse Engineering</b>
<pre><code>
.text:00161076 mov     [ebp+var_4], eax
.text:00161079 cmp     [ebp+var_4], 0E5h
.text:00161080 jnz     short loc_1610C4
.text:00161082 mov     ecx, 1
.text:00161087 shl     ecx, 2                          #ecx = 0x4
.text:0016108A mov     edx, [ebp+Dest]                 #pointer to start of our buffer
.text:0016108D movsx   eax, byte ptr [edx+ecx]         #Value of pointer+0x4 has to be 0x49 and move a byte
.text:00161091 cmp     eax, 49h
.text:00161094 jnz     short loc_1610A3
.text:00161096 mov     ecx, [ebp+Dest]
.text:00161099 mov     dword ptr [ecx+0C8h], 1         #Move 0x1 value to ecx+0C8h, 
.text:001610A3                                         so I win because after this function cmp pointer value with 0x1
.text:001610A3 loc_1610A3:                             ; CODE XREF: sub_161050+44
.text:001610A3 mov     edx, 1
.text:001610A8 imul    eax, edx, 5                     #eax = 0x5
.text:001610AB mov     ecx, [ebp+Dest]                 #pointer to start of our buffer
.text:001610AE movsx   edx, byte ptr [ecx+eax]         #Value of pointer+0x4 has to be 0x50 and move a byte
.text:001610B2 cmp     edx, 50h
.text:001610B5 jz      short loc_1610C4
.text:001610B7 mov     eax, [ebp+Dest]
.text:001610BA mov     dword ptr [eax+0C8h], 0
.text:001610C4
.text:001610C4 loc_1610C4:                             ; CODE XREF: sub_161050+30
.text:001610C4                                         ; sub_161050+65
.text:001610C4 xor     eax, eax
.text:001610C6 mov     esp, ebp
.text:001610C8 pop     ebp
.text:001610C9 retn
</code></pre>
